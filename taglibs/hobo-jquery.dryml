<!--

This is the jQuery plugin for Hobo.  This plugin provides the jQuery UI widgets in a Hobo friendly manner, provides useful tags and functions for jQuery javascript coding, and provides additional composite tags.

To use, see the [installation instructions](README.html)

The jQuery UI tags support all of the [options that the corresponding jQuery UI widgets provide](http://docs.jquery.com/UI).  For example:

    <hjq-datepicker dateFormat="yy-mm-dd" />

Options that expect a type other than string can be provided by passing a ruby object:

    <hjq-datepicker dayNamesMin="&['Di', 'Lu', 'Ma', 'Me', 'Je', 'Ve', 'Sa']" />

Events are also supported.  Pass in a global Javascript function name:

    <hjq-datepicker onSelect="hjq.log" />

-->

<!--
This is Hobo jQuery's standard tag annotation method.   This annotation is automatically added to Hobo jQuery tags, but you may wish to use it in your own tag definitions.

The current implementation uses HTML comments for annotation.  This may change in the future, if somebody can suggest a better mechanism.  [Here is a good discussion of the alternatives.](http://www.1729.com/blog/HtmlAnnotations.html).  Two more possibilities are http://www.w3.org/TR/xhtml-rdfa-primer and http://ejohn.org/blog/html-5-data-attributes/.

To use it, invoke this tag directly before the tag to annotate.  To get the annotations, call hjq.getAnnotations with _this_ set to the element that has been annotated.  For example:

    <def tag="mytag">
      <annotate-tag option_a="42"/>
      <div class="hjq-annotated">
        ...
      </div>
    </def>

    jQuery(this).find('.hjq-annotated').each(function() {
      var annotations = hjq.getAnnotations.call(this);
      ...
    });
-->
<def tag="annotate-tag">
  <%= "<!-- json_annotation (#{attributes.to_json}); -->" %>
</def>

<!--
These are the Hobo jQuery and jQuery assets required by Hobo jQuery.  You will probably wish to add this to your page definition:

    <extend tag="page">
      <old-page merge>
        <custom-scripts:>
          <hjq-assets/>
        </custom-scripts>
      </old-page>
    </extend>
-->
<def tag="hjq-assets">
  <jquery-assets/>
  <hobo-jquery-assets/>
</def>

<def tag="jquery-assets">
  <stylesheet name='smoothness/jquery-ui-1.7.custom.css' />
  <javascript name="jquery-1.3.2.min.js" />
  <javascript name="jquery-ui-1.7.custom.min.js" />
  <javascript name="jquery.form.js" />
</def>

<def tag="hobo-jquery-assets">
  <stylesheet name='hobo-jquery.css' />
  <javascript name="hobo-jquery.js" />
  <script type="text/javascript">
    jQuery.noConflict();
    jQuery(document).ready(function() {
      hjq.initialize.call(document);
    });
  </script>
</def>


<!--
This is the [jQuery-UI datepicker](http://docs.jquery.com/UI/Datepicker).

It's probably easiest to add this to your application.dryml:

    <def tag="input" for="Date">
      <hjq-datepicker dateFormat="yy-mm-dd" merge />
    </def>

It's probably useful to set global options such as dateFormat in application.dryml and set local options such as yearRange in the tag invocation:

    <input:birthdate yearRange="1900:#{Date.today.year}" />

-->
<def attrs="name, altField, altFormat, appendText, buttonImage, buttonImageOnly, buttonText, changeMonth, changeYear, closeText, constrainInput, currentText, dateFormat, dayNames, dayNamesMin, dayNamesShort, defaultDate, duration, firstDay, gotoCurrent, hideIfNoPrevNext, isRTL, maxDate, minDate, monthNames, monthNamesShort, navigationAsDateFormat, nextText, numberOfMonths, prevText, shortYearCutoff, showAnim, showButtonPanel, showCurrentAtPos, showMonthAfterYear, showOn, showOptions, showOtherMonths, stepMonths, yearRange, beforeShow, beforeShowDay, onChangeMonthYear, onClose, onSelect" tag="hjq-datepicker">
 <% option_names=['altField', 'altFormat', 'appendText', 'buttonImage', 'buttonImageOnly', 'buttonText', 'changeMonth', 'changeYear', 'closeText', 'constrainInput', 'currentText', 'dateFormat', 'dayNames', 'dayNamesMin', 'dayNamesShort', 'defaultDate', 'duration', 'firstDay', 'gotoCurrent', 'hideIfNoPrevNext', 'isRTL', 'maxDate', 'minDate', 'monthNames', 'monthNamesShort', 'navigationAsDateFormat', 'nextText', 'numberOfMonths', 'prevText', 'shortYearCutoff', 'showAnim', 'showButtonPanel', 'showCurrentAtPos', 'showMonthAfterYear', 'showOn', 'showOptions', 'showOtherMonths', 'stepMonths', 'yearRange'] %>
 <% event_names=['beforeShow', 'beforeShowDay', 'onChangeMonthYear', 'onClose', 'onSelect'] %>
 <% options = {}; option_names.each {|n| options[n]=all_attributes[n] if all_attributes.has_key?(n) }  %>
 <% events = {}; event_names.each {|n| events[n]=all_attributes[n] if all_attributes.has_key?(n) } %>
 <annotate-tag tag="hjq-datepicker" init="hjq.datepicker.init" options="&options" events="&events" />
 <% add_classes!(attributes, "hjq-annotated"); %>
 <%= text_field_tag(name, this, attributes) %>
</def>



<!-- Creates a sub-section of the form which the user can repeat using (+) and (-) buttons, in order to allow an entire `has_many` collection to be created/edited in a single form.

This tag is similar to the standard Hobo `<input-many>` tag, but it includes several additional features.

 - it supports 0 length associations
 - it supports delayed initialization, required for some Javascript elements like the jQuery UI datepicker
 - it allows the (+) and (-) buttons to be customized
 - it provides a default for the `item` parameter
 - it copies from a template rather than cloning the current item and clearing it
 - the template may be overridden
 - javascript hooks for (+) and (-)

It also fixes the following buglets in input-many:
 - id's of textareas and selects and other non-input's are adjusted properly
 - classdata for inner elements updated
 - the original input-many didn't clear textareas and select's.  We don't have a clear -> no buglet! :)

Because this implementation contains more than one parameter, the default parameter from input-many has been renamed to `item`.
 
### Example

Say you are creating a new `Category` in your online shop, and you want to create some initial products *in the same form*, you can add the following to your form:

    <hjq-input-many:products fields="name, price" />
    
You'll often want to provide the `item` parameter:

    <hjq-input-many:products><item:><field-list fields="name, price" /></item:></hjq-input-many>

A fully worked up example of nested hjq-input-many's may be found in [agility/jquery-test](http://github.com/tablatom/agility/blob/jquery-test/app/views/projects/nested_has_many_test.dryml)

### Attributes

 - minimum: the minimum number of items in the collection.  Currently only '0' and '1' are supported values.  The default is '0'.

 - fields: passed down to the `field-list` tag in the default `item`.

 - template: the default values for new items.  Normally this functionality is better provided by Model.new, but it's here if you need it.

 - add-hook: a javascript function to call after an item has been added.  The context will be set to the new item.

 - remove-hook: a javascript function to call before an item is removed.  The context will be set to the item.  If the hook returns false, the remove is cancelled.

### TODO

 - slide effect

  -->
<def tag="hjq-input-many" attrs="minimum, fields, new-template, remove-hook" polymorphic >
<%
# helper function to create id's on buttons to facilitate testing
def underize(s)
  s.gsub(/\[/,"_").gsub(/\]/,"")
end
%>
  <set empty="&this.empty?"/>
  <annotate-tag tag="hjq-input-many" init="hjq.input_many.init" merge-attrs="minimum, add-hook, remove-hook" />
  <ul class="hjq-input-many #{this_field.dasherize} #{css_data :input_many_prefix, param_name_for_this} hjq-annotated">
    <% template ||= this.try.new_candidate || this.member_class.new %>
    <% minimum ||= 0 ; minimum = minimum.to_i %>
    <fake-field-context fake-field="-1" context="&template">
      <li class="input-many-template" id="#{param_name_for_this}">
        <hjq-input-many-item param="item" merge-attrs="fields" />
        <div class="buttons">
          <button param="remove-item" id="#{underize param_name_for_this}_remove">-</button>
          <button param="add-item" id="#{underize param_name_for_this}_add">+</button>
        </div>
      </li>
    </fake-field-context>
    <li class="empty #{'hidden' unless this.empty? and minimum==0}" id="#{param_name_for_this}[-1]_empty">
      <!-- HACK way to signal an empty collection to the controller -->
      <input type="hidden" class="empty-input" id="#{param_name_for_this}" name="#{param_name_for_this}" value="" disabled="&(!this.empty? || minimum>0)" />
      <fake-field-context fake-field="-1" context="&template">
        <div param="empty-message">
          No <%= this.class.class_name.humanize.downcase.pluralize %>.
        </div>
        <div class="buttons">
          <button param="remove-item" class="hidden" id="#{underize param_name_for_this}_remove">-</button>
          <button param="add-item" id="#{underize param_name_for_this}_add">+</button>
        </div>
      </fake-field-context>      
    </li>
    <fake-field-context fake-field="0" context="&template">
      <li if="&(this_parent.empty? && minimum>0)" id="#{param_name_for_this}">
        <hjq-input-many-item param="item" merge-attrs="fields" />
        <div class="buttons">
          <button param="remove-item" class="hidden" id="#{underize param_name_for_this}_remove">-</button>
          <button param="add-item" id="#{underize param_name_for_this}_add">+</button>
        </div>
      </li>
    </fake-field-context>       
    <li repeat class="#{'record-with-errors' unless this.errors.empty?}" id="#{param_name_for_this}">
      <error-messages without-heading class="sub-record"/>
      <hidden-id-field/>
      <hjq-input-many-item param="item" merge-attrs="fields" />
      <div class="buttons">
        <button param="remove-item" class="#{'hidden' if this_parent.length<=minimum}" id="#{underize param_name_for_this}_remove">-</button>
        <button param="add-item" class="#{'hidden' if not last_item?}" id="#{underize param_name_for_this}_add">+</button>
      </div>
    </li>
  </ul>
</def>

<!--
    This is the default item used by `<hjq-input-many>`.  Redefine or extend if desired.
-->
<def tag="hjq-input-many-item" attrs="fields">
  <card param="default">
    <header: replace />
    <body:><field-list merge-attrs="fields" /></body:>
  </card>
</def>

<!--
`<formlet>` works like an AJAX `<form>` without actually being an AJAX `<form>`.  This is usefully in scenarios where forms aren't allowed or are problematic, like inside of another form.

### Attributes

 - standard Hobo HTML attributes (id, part, et cetera).  All supported.

 - standard Hobo AJAX attributes:  (see http://cookbook.hobocentral.net/api_taglibs/rapid_forms)
   
   - update: (optional).  The DOM ID's of parts to update.  Note that you get an AJAX formlet whether this is provided or not.

   - message: the spinner message

   - spinner_next_to: DOM id of an element to position the ajax progress spinner next to.

   - before, success, error, complete: These callbacks are slightly different from the standard form callbacks.  They are called with "this" set to the formlet.  Also, you may pass in a function name rather than a javascript fragment.  If the before callback returns false, it will cancel the submission.

   - confirm: a message to be displayed in a JavaScript confirm dialog. By default there is no confirm dialog

   - not supported: type, script, form, params, confirm, reset_form, refocus_form, result_update.  None of these are particularly hard to support.  Email or post a message to the list if you need them.

 - standard Hobo Form attributes (all supported):

   - hidden-fields

   - action

   - method

   - web-method

   - lifecycle

   - owner
-->
<def tag="formlet" polymorphic attrs="update, hidden-fields, action, method, web-method, lifecycle, owner">
<%
#FIXME: code very similar to <form>.  refactor out common code.

  ajax_attrs, html_attrs = attributes.partition_hash(Hobo::RapidHelper::AJAX_ATTRS)

  ajax_options = {}

  new_record = this.try.new_record?

  method = if method.nil?
             (action || web_method || new_record) ? "post" : "put"
           else
             method.downcase
           end

  ajax_options[:url] ||= begin
     target = if owner
                collection_name = this.class.reverse_reflection(owner).name
                this.send(owner).send(collection_name)
              else
                this
              end
     action = web_method || lifecycle
     object_url(target, action, :method => "post")
  end

  if action.nil? && (ajax_options[:url].nil? ||
                     (lifecycle.nil? && new_record && !this.creatable_by?(current_user)) ||
                     (lifecycle.nil? && !new_record && !can_edit?))
    Hobo::Dryml.last_if = false
    logger.info("blank!!!")
    ""
  else
    if method == "put"
      # browsers don't support put -- use post and add the Rails _method hack
      http_method_hidden = hidden_field_tag("_method", "PUT") 
      ajax_options[:type] = "post"
    else
      ajax_options[:type] = method
    end

    ajax_attrs[:update] = if update 
                            update.split(/,\s*/) 
                          else
                            []
                          end

    hiddens = nil
    body = with_form_context do
      # It is important to evaluate parameters.default first, in order to populate scope.form_field_names
      b = parameters.default
      hiddens = self.hidden_fields(:fields => hidden_fields) if new_record
      b
    end

    auth_token = if method.nil? || method == 'get' || !protect_against_forgery?
                   ''
                 else
                   element(:input, {:type => "hidden", 
                           :name => request_forgery_protection_token.to_s,
                           :value => form_authenticity_token}, nil, true, true)
                 end
     
    unless method == "get"
      page_path = if (request.post? || request.put?) && params[:page_path]
                    params[:page_path]
                  else
                    view_name.sub(Hobo::Dryml::EMPTY_PAGE, params[:action])
                  end
      page_path_hidden = hidden_field_tag("page_path", page_path) 
    end

    hiddens_div = element(:div, {:class => "hidden-fields"}, [http_method_hidden, page_path_hidden, auth_token, hiddens].join)
     
    body = [hiddens_div, body].join

    if action.nil? # don't add automatic css classes if the action was specified
      if web_method
        add_classes!(html_attrs, "#{type_id.dasherize}-#{web_method}-form")
      else
        add_classes!(html_attrs, "#{'new ' if new_record}#{type_id.dasherize}")
      end
    end

    Hobo::Dryml.last_if = true
  end

  add_classes!(html_attrs, "formlet")
%>
<annotate-tag tag="formlet" ajax-attrs="&ajax_attrs" ajax-options="&ajax_options" />
  <%= element("div", html_attrs, body) %>
</def>

<!--
Submit button for use with `<formlet>`.  Submit won't work, because `<formlet>` isn't a form.
-->
<def tag="formlet-submit" attrs="label, image, method">
  <% label ||= 'submit' %>
  <if test='&image'>
    <input class='image-button formlet-submit-button' type='image' src='&image' merge-attrs />
  </if>
  <else>
    <input class='button formlet-submit-button' type='button' value='#{label}' onClick='hjq.formlet.submit.call(this)' merge-attrs />
  </else>
</def>
