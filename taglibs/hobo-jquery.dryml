!--

This is the jQuery plugin for Hobo.  This plugin provides the jQuery UI widgets in a Hobo friendly manner, provides useful tags and functions for jQuery javascript coding, and provides additional composite tags.

To use, see the [installation instructions](http://cookbook.hobocentral.net/plugins/hobo-jquery)  [(alternate link)](README.html)

The jQuery UI tags support all of the [options that the corresponding jQuery UI widgets provide](http://docs.jquery.com/UI).  For example:

    <hjq-datepicker dateFormat="yy-mm-dd" />

Options that expect a type other than string can be provided by passing a ruby object:

    <hjq-datepicker dayNamesMin="&['Di', 'Lu', 'Ma', 'Me', 'Je', 'Ve', 'Sa']" />

Events are also supported.  Pass in a global Javascript function name:

    <hjq-datepicker onSelect="hjq.util.log" />

-->

<!--
This is Hobo jQuery's standard tag annotation method.   This annotation is automatically added to Hobo jQuery tags, but you may wish to use it in your own tag definitions.

The current implementation uses HTML comments for annotation.  This may change in the future, if somebody can suggest a better mechanism.  [Here is a good discussion of the alternatives.](http://www.1729.com/blog/HtmlAnnotations.html).  Two more possibilities are http://www.w3.org/TR/xhtml-rdfa-primer and http://ejohn.org/blog/html-5-data-attributes/.

To use it, invoke this tag directly before the tag to annotate.  To get the annotations, call hjq.getAnnotations with _this_ set to the element that has been annotated.  For example:

    <def tag="mytag">
      <annotate-tag option_a="42"/>
      <div class="rapid-annotated">
        ...
      </div>
    </def>

    jQuery(this).find('.rapid-annotated').each(function() {
      var annotations = hjq.getAnnotations.call(this);
      ...
    });
-->
<def tag="annotate-tag">
  <%= "<!-- json_annotation (#{attributes.to_json}); -->".html_safe %>
</def>

<!--
These are the Hobo jQuery and jQuery assets required by Hobo jQuery.  You will probably wish to add this to your page definition:

    <extend tag="page">
      <old-page merge>
        <custom-scripts:>
          <hjq-assets/>
        </custom-scripts>
      </old-page>
    </extend>
-->
<def tag="hjq-assets">
  <jquery-assets/>
  <hobo-jquery-assets/>
</def>

<def tag="jquery-assets">
  <stylesheet name='smoothness/jquery-ui-1.8.11.custom.css' />
  <javascript name="jquery.min.js" />
  <javascript name="jquery-ui.min.js" />
</def>

<def tag="hobo-jquery-assets">
  <stylesheet name='hobo-jquery.css' />
  <javascript name="hobo-jquery.js" />
  <script type="text/javascript">
    jQuery(document).ready(function() {
      hjq.initialize.call(document);
    });
  </script>
</def>


<!--
This is the [jQuery-UI datepicker](http://docs.jquery.com/UI/Datepicker).  All options and events are supported.

It's probably easiest to add this to your application.dryml:

    <def tag="input" for="Date">
      <hjq-datepicker dateFormat="yy-mm-dd" merge />
    </def>

It's probably useful to set global options such as dateFormat in application.dryml and set local options such as yearRange in the tag invocation:

    <input:birthdate yearRange="1900:#{Date.today.year}" />

New in version 1.4:

If you do not specify dateFormat, we will attempt to convert I18n.t(:"date.formats.default") from strftime format into the format that the JQuery-UI datepicker likes.

-->
<def attrs="name" tag="hjq-datepicker">
<%
  options, attrs = attributes.partition_hash(['altField', 'altFormat', 'appendText', 'buttonImage', 'buttonImageOnly', 'buttonText', 'changeMonth', 'changeYear', 'closeText', 'constrainInput', 'currentText', 'dateFormat', 'dayNames', 'dayNamesMin', 'dayNamesShort', 'defaultDate', 'duration', 'firstDay', 'gotoCurrent', 'hideIfNoPrevNext', 'isRTL', 'maxDate', 'minDate', 'monthNames', 'monthNamesShort', 'navigationAsDateFormat', 'nextText', 'numberOfMonths', 'prevText', 'selectOtherMonths','shortYearCutoff', 'showAnim', 'showButtonPanel', 'showCurrentAtPos', 'showMonthAfterYear', 'showOn', 'showOptions', 'showOtherMonths', 'stepMonths', 'yearRange'])
  options["dateFormat"]||=begin
                            d=I18n.t(:"date.formats.default")
                            {"%Y" => "yy",
                             "%y" => "y",
                             "%m" => "mm",
                             "%_m" => "m",
                             "%-m" => "m",
                             "%B" => "MM",
                             "%^B" => "MM",
                             "%b" => "M",
                             "%^b" => "M",
                             "%h" => "M",
                             "%d" => "dd",
                             "%-d" => "d",
                             "%j" => "oo",
                             "%D" => "mm/dd/y",
                             "%F" => "yy-mm-dd",
                             "%x" => "mm/dd/y"}.each {|rb, js| d.gsub!(rb,js)}
                           d
                         end
  events, html_attrs = attrs.partition_hash(['beforeShow', 'beforeShowDay', 'onChangeMonthYear', 'onClose', 'onSelect'])
  add_classes!(html_attrs, "rapid-annotated")
  add_data_rapid!(html_attrs, "datepicker", :options => options, :events => events)
%>
 <%= text_field_tag(name, this, html_attrs) %>
</def>


<!--
This is the [jQuery-UI autocompleter](http://jqueryui.com/demos/autocomplete/).  All options and events provided by the jQuery autocompleter are supported in this Hobo tag.   Refer to the jquery autocomplete documentation for more details.

This tag works very similarly to the `name-one` tag used in Hobo.  The main reason I use `hjq-autocomplete` is that the scriptaculous widget used by Hobo for `name-one` does not work well in Internet Explorer:  https://prototype.lighthouseapp.com/projects/8887/tickets/33

If you do not provide a `source` option, this tag will essentially provide a default similar to this:

    <hjq-autocomplete:project source="&Project.find(:all, :limit => 5000).map {|p| p.name}" />

This will provide a local autocomplete, putting all possible options into your HTML.  This is useful when you have too many options to make a `select-one` infeasible, but will overload your server and crash your browser if you have millions of options.

To do a server side autocomplete, use a path for your source option:

    <hjq-autocomplete:project source="&query_projects_path" delay="500" minLength="3" />

And add something like this to your controller:

    index_action :query do
      render :json => Project.name_contains(params[:term]).limit(100).*.name
    end
-->
<def tag="hjq-autocomplete">
<%
  options, attrs = attributes.partition_hash(['disabled', 'appendTo', 'autoFocus', 'delay', 'minLength', 'position', 'source'])
  events, html_attrs = attrs.partition_hash(['create', 'search', 'open', 'focus', 'select', 'close', 'change'])
  options["source"] ||= begin
                          complete_target = this_field_reflection.klass
                          complete_target.find(:all, :limit => 5000).*.send(complete_target.name_attribute)
                        end

%>
 <annotate-tag tag="hjq-autocomplete" init="hjq.autocomplete.init" options="&options" events="&events" />
 <% html_attrs = add_classes(html_attrs, "rapid-annotated") 
    html_attrs["name"] ||= param_name_for_this
    html_attrs["value"] ||= name(:no_wrapper => true, :if_present => true)
 %>
 <%= text_field_tag(name, this, html_attrs) %>

</def>


<!-- Creates an enhanced version of the [jQuery-UI demo combobox](http://jqueryui.com/demos/autocomplete/#combobox).  This will turn any select (even a select-many) into a combobox.

NOTE:  backwards compatibility with the Hobo&Rails prototype/lowpro handlers requires event.simulate.js.   You may need to rerun your hobo_query:install generator to copy this file into your application.

Standard usage:

    <hjq-combobox>
      <select .../>
    </hjq-combobox>

If you don't supply the select, it will use Hobo's `<input>` tag.  This is usually the right default.

You can tell Hobo to always use a combobox for select-one, select-many, select-input and/or select-menu.   Notice that we also changed the limit - 100 is the default, which makes sense for a select, but not for a combobox.

    <extend tag="select-one">
      <hjq-combobox tag="select-one">
        <old-select-one limit="5000" merge/>
      </hjq-combobox>
    </extend>

To make the behavior more like the demo's, turn off autoFill and clearButton:

    <hjq-combobox autoFill="&false" clearButton="&false"/>

Combobox is a new control that is built on autocomplete.   The autocomplete options may not be used directly.   If you need any of them let me know, they should not be too hard to add if you volunteer to test them.

### Attributes

- `autoFill` (default: true):  select first value rather than clearing if there's a match

- `clearButton` (default: true): add a "clear" button

- `adjustWidth` (default: true): if true, will set the autocomplete width the same as the old select.  (requires jQuery 1.4.4 to work on IE8)

- uiStyle (default: false): if true, will add classes so that the autocomplete input takes a jQuery-UI style.  If false, the standard Hobo style is used.

### Events

- `selected` (default: `$(this).simulate('change');`):  this is a jQuery-UI event handler.  The default value for this option fires the `onchange` handler on the underlying `select` in a manner compatible with both prototype.js and jQuery.  For this to work, event.simulate.js must be loaded, and jQuery must be put into noConflict mode.  hobo-jquery should be doing both of these for you if you are using it as recommended in the README.

-->

<def tag="hjq-combobox" options="tag">
<%
  options, attrs = attributes.partition_hash(['autoFill', 'clearButton', 'adjustWidth', 'uiStyle'])
  events, html_attrs = attrs.partition_hash(['selected'])
%>
  <annotate-tag tag="hjq-combobox" init="hjq.combobox.init" options="&options" events="&events"/>
  <% tag ||= 'input' %>
  <span class="hjq-combobox rapid-annotated" param="default">
    <input merge param />
  </span>
</def>


<!-- Creates a sub-section of the form which the user can repeat using (+) and (-) buttons, in order to allow an entire `has_many` collection to be created/edited in a single form.

Most of the enhancements from hjq-input-many have been folded back into hjq-input-many, but there are a few remaining differences:

 - it supports delayed initialization, required for some Javascript elements like the jQuery UI datepicker
 - the name of the main parameter is `item` rather than `default`
 - hjq-input-many allows you to provide javascript callbacks.  input-many fires
    rapid:add, rapid:change and rapid:remove events that can be hooked.
 
### Example

Say you are creating a new `Category` in your online shop, and you want to create some initial products *in the same form*, you can add the following to your form:

    <hjq-input-many:products fields="name, price" />
    
You'll often want to provide the `item` parameter:

    <hjq-input-many:products><item:><field-list fields="name, price" /></item:></hjq-input-many>

A fully worked up example of nested hjq-input-many's may be found in [agility/jquery-test](http://github.com/tablatom/agility/blob/jquery-test/app/views/projects/nested_has_many_test.dryml)

### Attributes

 - `minimum`: the minimum number of items in the collection.  Currently only '0' and '1' are supported values.  The default is '0'.

 - `fields`: passed down to the `field-list` tag in the default `item`.

 - `template`: the default values for new items.  Normally this functionality is better provided by Model.new, but it's here if you need it.

 - `add-hook`: a javascript function to call after an item has been added.  The context will be set to the new item.

 - `remove-hook`: a javascript function to call before an item is removed.  The context will be set to the item.  If the hook returns false, the remove is cancelled.


  -->
<def tag="hjq-input-many" attrs="minimum, fields, template, add-hook, remove-hook" polymorphic >
<%
# helper function to create id's on buttons to facilitate testing
def underize(s)
  s.gsub(/\[/,"_").gsub(/\]/,"")
end
%>
  <set empty="&this.empty?"/>
  <annotate-tag tag="hjq-input-many" init="hjq.input_many.init" merge-attrs="minimum, add-hook, remove-hook" />
  <ul class="hjq-input-many #{this_field.dasherize} #{css_data :input_many_prefix, param_name_for_this} rapid-annotated" merge-attrs="&attributes - attrs_for(:hjq_input_many_item)">
    <% template ||= this.try.new_candidate || this.member_class.new %>
    <% minimum ||= 0 ; minimum = minimum.to_i %>
    <fake-field-context fake-field="-1" context="&template">
      <li class="input-many-template" id="#{param_name_for_this}">
        <hjq-input-many-item param="item" merge-attrs="fields" />
        <div class="buttons">
          <button param="remove-item" id="#{underize param_name_for_this}_remove">-</button>
          <button param="add-item" id="#{underize param_name_for_this}_add">+</button>
        </div>
      </li>
    </fake-field-context>
    <li class="empty #{'hidden' unless this.empty? and minimum==0}" id="#{param_name_for_this}[-1]_empty">
      <!-- HACK way to signal an empty collection to the controller -->
      <input type="hidden" class="empty-input" id="#{param_name_for_this}" name="#{param_name_for_this}" value="" disabled="&(!this.empty? || minimum>0)" />
      <fake-field-context fake-field="-1" context="&template">
        <div param="empty-message">
          <ht key="#{this.class.to_s.underscore}.collection.empty_message">          
            No <%= this.class.name.titleize.downcase.pluralize %>.
          </ht>
        </div>
        <div class="buttons">
          <button param="remove-item" class="hidden" id="#{underize param_name_for_this}_remove">-</button>
          <button param="add-item" id="#{underize param_name_for_this}_add">+</button>
        </div>
      </fake-field-context>      
    </li>
    <fake-field-context fake-field="0" context="&template">
      <li if="&(this_parent.empty? && minimum>0)" id="#{param_name_for_this}">
        <hjq-input-many-item param="item" merge-attrs="fields" />
        <div class="buttons">
          <button param="remove-item" class="hidden" id="#{underize param_name_for_this}_remove">-</button>
          <button param="add-item" id="#{underize param_name_for_this}_add">+</button>
        </div>
      </li>
    </fake-field-context>       
    <li repeat class="#{'record-with-errors' unless this.errors.empty?}" id="#{param_name_for_this}">
      <error-messages without-heading class="sub-record"/>
      <hidden-id-field/>
      <hjq-input-many-item param="item" merge-attrs="fields" />
      <div class="buttons">
        <button param="remove-item" class="#{'hidden' if this_parent.length<=minimum}" id="#{underize param_name_for_this}_remove">-</button>
        <button param="add-item" class="#{'hidden' if not last_item?}" id="#{underize param_name_for_this}_add">+</button>
      </div>
    </li>
  </ul>
</def>

<!--
    This is the default item used by `<hjq-input-many>`.  Redefine or extend if desired.
-->
<def tag="hjq-input-many-item" attrs="fields">
  <card param="default">
    <header: replace />
    <body:><field-list merge-attrs="fields" /></body:>
  </card>
</def>

<!--
`<formlet>` works like an AJAX `<form>` without actually being an AJAX `<form>`.  This is useful in scenarios where forms aren't allowed or are problematic, like inside of another form.

### Attributes

 - standard Hobo HTML attributes (id, part, et cetera).  All supported.

 - standard Hobo AJAX attributes:  (see [the cookbook](http://cookbook.hobocentral.net/api_taglibs/rapid_forms) )
   
   - `update`: (optional).  The DOM ID's of parts to update.  Note that you get an AJAX formlet whether this is provided or not.

   - `message`: the spinner message

   - `spinner-next-to`: DOM id of an element to position the ajax progress spinner next to.

   - `before`, `success`, `error`, `complete`: These callbacks are slightly different from the standard form callbacks.  They are called with "this" set to the formlet.  Also, you may pass in a function name rather than a javascript fragment.  If the before callback returns false, it will cancel the submission.

   - `confirm`: a message to be displayed in a JavaScript confirm dialog. By default there is no confirm dialog

   - not supported: `type, script, params, reset-form, refocus-form, result-update`.  None of these are particularly hard to support.  Email or post a message to the list if you need them.

 - standard Hobo Form attributes (all supported):

   - `hidden-fields`

   - `action`

   - `method`

   - `web-method`

   - `lifecycle`

   - `owner`
-->
<def tag="formlet" polymorphic attrs="element">
<%
  body, html_attrs, ajax_attrs, form_attrs = form_helper(attributes, parameters)
  element ||= 'div'
  unless body.nil?
    add_classes!(html_attrs, "formlet")
    add_data_rapid!(html_attrs, :formlet, :form_attrs => form_attrs, :ajax_attrs => ajax_attrs)
%>
    <%= element(element, html_attrs, body) %>
<%
  end
%>
</def>


<!--
`<form>` has been extended in Rapid to make it easier to construct and use forms with Hobo models. In addition to the base
`<form>` tag, a form with contents is generated for each Hobo model. These are found in
`app/views/taglibs/auto/rapid/forms.dryml`.

### Usage

`<form>` can be used as a regular HTML tag:

        <form action="/blog_posts/1" method="POST">...</form>

If no `action` attribute is provided then the context is used to construct an appropriate action using restful routing:

* If the context is a new record then the form action will be a `POST` to the create action:

        <form with="&BlogPost.new">...</form> -> <form action="/blog_posts" method="POST">...</form>

* If the context is a saved record then the form action will be a `PUT` to the update action. This is handled in a special
  way by Rails due to current browsers not supporting `PUT`, the method is set to `POST` with a hidden input called `_method`
  with a value of `PUT`. Hobo adds this automatically:

        <% blog_post = BlogPost.find(1) %>
        <form with="&blog_post">...</form> ->
        <form action="/blog_posts/1" method="POST">
          <input id="_method" type="hidden" value="PUT" name="_method"/>
          ...
        </form>

AJAX based submission can be enabled by simply adding an `update` attribute. e.g.

        <div part="comments"><collection:comments/></div>
        <form with="&Comment.new" update="comments"/>

More information on Ajax can be viewed in the [manual](/manual/ajax#forms) or in the [Rapid Forms index](/api_taglibs/rapid_forms).

### Additional Notes

- Hobo automatically inserts an `auth_token` hidden field if forgery protection is enabled

- Hobo inserts a `page_path` hidden field in create / update forms which it uses to re-render the correct page if a
  validation error occurs.

- `<form>` supports all of the standrd ajax attributes - (see the main taglib docs for Rapid Forms)

- `<form>` resets `last_if` if it does not have permission to display the form.   The `<else>` clause may be used to display alternate content.   For example:

    <form>...</form>
    <else>You do not have permission to edit this form</else>

or on a standard generated page using a default form:

    <some-page>
      <after-form:>
        <else>You do not have permission to edit this form</else>
      </after-form:>
    </some-page>

### Attributes

 - [all AJAX attributes](/api_taglibs/rapid_forms)

 - action: the controller action.  Default is create or update as appropriate

 - method: PUT or POST

 - web-method

 - lifecycle

 - owner

 - multipart: if set, the encoding is set to multipart/form-data.  The default is x-www-form-urlencoded

 - reset-form: Clear the form after submission (only makes sense for ajax forms)

 - refocus-form: Refocus the first form-field after submission (only makes sense for ajax forms)

### Parameters

The standard form tag does not have any parameters, nor does it have any default content.   However, Hobo does autogenerate polymorphic form tags for each of your models into `app/views/taglibs/auto/rapid/forms.dryml`.  These forms have the following parameters:

 - error-messages

 - field-list

 - actions

 - submit

 - cancel

-->
<def tag="form" polymorphic >
<%
  body, html_attrs, ajax_attrs, form_attrs = form_helper(attributes, parameters)
  add_data_rapid!(html_attrs, :form, :ajax_attrs => ajax_attrs) unless ajax_attrs.empty?
%>
  <%= element("form", html_attrs.merge(form_attrs), body) if body %>
</def>


<!--
Submit button for use with `<formlet>`.  Submit won't work, because `<formlet>` isn't a form.
-->
<def tag="formlet-submit" attrs="label, image, method">
  <% label ||= 'submit' %>
  <if test='&image'>
    <input class='image-button formlet-submit-button' type='image' src='&image' onClick='hjq.formlet.submit.call(this)' merge-attrs />
  </if>
  <else>
    <input class='button formlet-submit-button' type='button' value='#{label}' onClick='hjq.formlet.submit.call(this)' merge-attrs />
  </else>
</def>

<!--
Submit button for use with the `<form>`.  This uses hjq.form.submit to
submit the form via jquery form plugin ajax, rather than using the
standard HTTP or Hobo form submission mechanisms.  The main advantage
this has is that the jquery form plugin supports ajax submission of
attachments.

You must have the jquery form plugin installed.  It is not installed
automatically by hobo-jquery.

FIXME: this function HARD CODES it's ajax options, in particular
update="attachments-div".  It does not (yet) get the parameters from
the form, nor does it get them through the standard hobo-jquery
mechanism.   update in hobo-jquery.js.
-->
<def tag="hjq-submit" attrs="label, image, method">
  <% label ||= 'submit' %>
  <if test='&image'>
    <input class='image-button hjq-form-submit-button' type='image' src='&image' onClick='hjq.form.submit.call(this)' merge-attrs />
  </if>
  <else>
    <input class='button hjq-form-submit-button' type='button' value='#{label}' onClick='hjq.form.submit.call(this)' merge-attrs />
  </else>
</def>

<!--
The JQuery UI [dialog](http://jqueryui.com/demos/dialog/).  All options and methods are supported.

The default for [autoOpen](http://jqueryui.com/demos/dialog/#option-autoOpen) has been changed to `"&false"`.  To display the dialog set autoOpen to `"&true"`, use a `<hjq-dialog-open-button>`, use the [jQuery dialog open method](http://jqueryui.com/demos/dialog/#method-open), or use an `<hjq-dialog-and-button>` instead.

The default for [position](http://jqueryui.com/demos/dialog/#option-position) is also set so that the dialog appears where it is defined.

The [buttons](http://jqueryui.com/demos/dialog/#option-buttons) option has been changed slightly.  Instead of an Hash, it expects a list of pairs.  (Unlike Javascript Objects, Ruby Hash's do not preserve order).  Because of quoting issues, it's usually easier to assign the list to a variable and then include the list:

    <% buttons = [ ["cancel", "jQuery(this).dialog('close')"] ] %>
    <hjq-dialog buttons="&buttons" />

or

    <hjq-dialog id="story-dialog" buttons='&{"cancel" => "jQuery(this).dialog(\"close\")"}' />

or

    <hjq-dialog id="story-dialog" buttons='&{"cancel" => "hjq.dialog.close"}' />

Because Ruby Hash's do not preserve order, you may use a list of pairs instead of a Hash.

JQuery UI is sometimes picky about types.   For instance, the width option must be a number, not a string.  By default Hobo options are strings, but you can easily send a number by using the ampersand to switch to ruby mode:

    <hjq-dialog width="&640"/>

The following functions are predefined for use in dialog buttons:

 * `hjq.dialog.close`:  close the dialog box
 * `hjq.dialog.submitFormlet`:  submits all formlets inside the dialog
 * `hjq.dialog.submitFormletAndClose`: submits any enclosed formlets, then closes the dialog.
-->
<def tag="hjq-dialog" attrs="buttons">
<% #FIXME: dry these names
 options, attrs = attributes.partition_hash(["autoOpen", "bgiframe", "closeOnEscape", "dialogClass", "draggable", "height", "hide", "maxHeight", "maxWidth", "minWidth", "modal", "position", "resizable", "show", "stack", "title", "width", "zIndex"])
 events, html_attrs = attrs.partition_hash(["beforeclose", "open", "focus", "dragStart", "drag", "dragStop", "resizeStart", "resize", "resizeStop", "close"])
 options["autoOpen"]=false unless options.has_key?("autoOpen")
%>
 <span class="hjq-dialog-position"></span>
 <annotate-tag tag="hjq-dialog" init="hjq.dialog.init" options="&options" events="&events" buttons="&buttons" />
 <% html_attrs = add_classes(html_attrs, "rapid-annotated hidden hjq-dialog"); %>
 <div merge-attrs="&html_attrs" param="default" />
</def>

<!--
When pressed, will open a `<hjq-dialog>`.

### Attributes
 * `dialog` (required):a CSS selector (AKA jQuery selector) to locate the dialog in the DOM.  Remember, if you're passing an ID, place a '#' in front of the ID.
 * supports all `<button>` attributes except for `onclick`

### Example
    <hjq-dialog id="hello-dialog">Hello!</hjq-dialog>
    <hjq-dialog-open-button dialog="#hello-dialog">Press Me!</hjq-dialog-open-button>
-->
<def tag="hjq-dialog-open-button" attrs="dialog">
  <button onclick="hjq.dialog_opener.click(this, jQuery('#{dialog}')); return false;" param="default" class="hjq-dialog-open-button" merge />
</def>

<!--
Defines an `<hjq-dialog>` and a `<hjq-dialog-open-button>` and links the two together.

### Attributes
 * `id` (optional): the DOM id to use for the dialog
-->
<def tag="hjq-dialog-and-button">
  <% # we can't use jQuery traversal functions since the dialog will move around in the DOM %>
  <% attributes["id"]="hjq-dialog-#{(rand*1000000000).to_i}" unless attributes.has_key?("id") %>
  <hjq-dialog param merge />
  <hjq-dialog-open-button dialog="##{attributes['id']}" param />
</def>

<!--
Defines a `<select-one>` and a button that brings up an `<hjq-dialog>` containing a form allowing you to enter a new item.  After the form is filled in and closed, the `<select-one>` is changed to select the new item.

### Caveats

`select-one-or-new-dialog` is a very simple control that depends on a large number of Hobo and hobo-jquery components to be working correctly in the standard manner.   These include ajax, a standard form context, and formlets.

#### sort order

The javascript for this control is a quick hack that assumes the new item created will be the last item in the select.   If you've defined a sort order, this assumption will be broken.   It will also be broken if there are more items than the select-one limit.

#### parameterizing parts

Because the select-one is a part, it cannot be parameterized.  However, you can adjust its definition by defining the polymorphic input for the type:

    <def tag="input" for="StoryStatus">
      <select-one include-none="&false" />
    </def>

#### controller actions

For Hobo ajax to work, standard controller actions are required.   If you have customized the sub-item's create action, you may break select-one-or-new-dialog.

There is one case where you have to customize the create action.   For Ajax to work, Hobo has to resurrect the context.   This is straightforward if the parent context exists in the database.   If it does not, then Hobo uses whatever 'this' is created by the controller action.   In our case, this is usually the wrong thing.

Example:

    class Story
      hobo_model
      fields do
        name :string
      end
      belongs_to :story_status
      # plus permissions, etc...
    end

app/views/stories/new.dryml:

    <new-page>
      <field-list:>
        <story-status-view:>
          <select-one-or-new-dialog/>
        </story-status-view:>
      </field-list:>
    </new-page>

app/controllers/story_statuses_controller.rb:

    class StoryStatusesController < ApplicationController
      def create
        hobo_create do
          if request.xhr?
            self.this = Story.new
          end
        end
      end
    end


-->
<def tag="select-one-or-new-dialog">
  <% dialog_id="hjq-dialog-#{typed_id.gsub(':', '-')}" %>
  <% part_id = "select-one-#{typed_id.gsub(':', '-')}" %>
  <input part="select-one-or-new-dialog-select" id="#{part_id}"/>
  <hjq-dialog-open-button dialog="##{dialog_id}" param>
    New <% this_field.humanize %>
  </hjq-dialog-open-button>
  <hjq-dialog param buttons='&[["cancel", "hjq.dialog.close"], ["ok", "hjq.dialog.submitFormletAndClose"]]' title="New #{this_field.humanize}" id="&dialog_id" >
    <formlet with="&this_type.new" update="&part_id" success="jQuery('##{part_id} select').val(jQuery('##{part_id} option:last').val())">
      <field-list />
    </formlet>
  </hjq-dialog>
</def>


<def tag="hjq-rapid-json">
  <%
     # FIXME: This should interrogate the model-router - not the models
     unless Hobo::Model.all_models.empty?
       # Tell JS code how to pluralize names, unless they follow the simple rule
       names = {}
       Hobo::Model.all_models.each do |m|
         m = m.name.underscore
         names[m] = m.pluralize unless m.pluralize == m + 's'
       end.compact
     end
               %>
  <annotate-tag  pluralisations="&names"
                 url-base="&[base_url, subsite].compact.join('/')"
                 hobo-page-path="&request.fullpath"
                 form-auth-token="&{ 'name' => request_forgery_protection_token, 'value' => form_authenticity_token}"
                 hobo-parts="&part_contexts_storage_uncoded"/>

  <span class="rapid-data"/>
</def>

<!--
-->
<def tag="toggle-edit" attrs="view">
<%
  options, attrs = attributes.partition_hash(['copyCss', 'eventsEnabled', 'stickyFocus', 'defaultText', 'events'])
  events, html_attrs = attrs.partition_hash(['onedit', 'onpreview', 'oncanceledit', 'oncancelpreview'])
  html_attrs = add_classes(html_attrs, "rapid-annotated toggle-edit");
%>
 <annotate-tag tag="toggle-edit" view="&view" options="&options" events="&events" />
 <input param="default" merge-attrs="&html_attrs" />
</def>

<!--
An in-place-editor type control.  Displays the `view` view of a field
until it's clicked on, when it switches to the `input` view.  Onchange
the field is saved via Ajax, and onblur the view switches back to the
`view` view.

Due to the way the DRYML part system works, `<click-editor>` may not
be parameterized.  If you wish to parameterize it, see
`<click-editor-innards>`.
-->
<def tag='click-editor'>
  <div part="editor-part">
    <click-editor-innards/>
  </div>
</def>

<!--
When placed inside of a part, provides a complete parameterizable `<click-editor>`.

### Usage

    <part name="my-part">
      <click-editor-innards>
        <before-view:>My</before-view:>
        <view: replace>
          My <view restore/>
        </view: replace>
      </click-editor-innads>
    </part>

### Attributes

blank-message: the message to display if the field is blank.  Note
that you're probably better off changing this via translations
(hobo.in_place_editor.click_to_edit).

-->
<def tag='click-editor-innards' attrs="blank-message">
  <% blank_message ||= t('hobo.in_place_editor.click_to_edit', :default => '(click to edit)') %>
    <if>
      <view class="in-place-edit hidden" data-rapid="&data_rapid(:click_editor)" param/>
    </if>
    <else>
      <view with="&blank_message" class="in-place-edit hidden" data-rapid="&data_rapid(:click_editor)" param="blank-view"/>
    </else>
    <set my-field="&this_field"/>
    <formlet with="&this_parent" class="in-place-form" ajax errors-ok param>
      <error-messages param/><%# TODO: replace with something more compact, maybe even transient %>
      <input field="&my_field" param/>
    </formlet>
</def>

<!--
A simpler in-place-editor type control.  Renders an `input` of the
field that is automatically saved via Ajax onchange.
-->
<def tag='live-editor'>
  <div part="live-editor-part">
    <set my-field="&this_field"/>
    <formlet with="&this_parent" class="in-place-form" ajax errors-ok data-rapid="&data_rapid(:live_editor)">
      <error-messages/><%# TODO: replace with something more compact, maybe even transient %>
      <input field="&my_field"/>
    </formlet>
  </div>
</def>

<def tag="input" for="Date">
  <hjq-datepicker merge/>
</def>

<def tag="editor" polymorphic/>
<def tag="editor" for="string"><click-editor merge /></def>
<def tag="editor" for="text"><click-editor merge /></def>
<def tag="editor" for="html"><click-editor merge /></def>
<def tag="editor" for="datetime"><click-editor merge /></def>
<def tag="editor" for="date"><click-editor merge /></def>
<def tag="editor" for="integer"><click-editor merge /></def>
<def tag="editor" for="BigDecimal"><click-editor merge /></def>
<def tag="editor" for="float"><click-editor merge /></def>
<def tag="editor" for="boolean"><live-editor merge /></def>
<def tag="editor" for="HoboFields::Types::EnumString"><live-editor merge /></def>

<def tag="sortable-collection">
<%
  options, attrs = attributes.partition_hash(['disabled', 'appendTo', 'axis', 'cancel', 'connectWith', 'containment', 'cursor', 'cursorAt', 'delay', 'distance', 'dropOnEmpty', 'forceHelperSize', 'forcePlaceholderSize', 'grid', 'handle', 'helper', 'items', 'opacity', 'placeholder', 'revert', 'scroll', 'scrollSensitivity', 'scrollSpeed', 'tolerance', 'zIndex'])
  events, html_attrs = attrs.partition_hash(['create', 'start', 'sort', 'change', 'beforeStop', 'stop', 'update', 'receive', 'remove', 'over', 'out', 'activate', 'deactivate'])

  singular_name = this.member_class.name.underscore
  route_method = subsite ? "#{subsite}_reorder_#{singular_name.pluralize}_url" : "reorder_#{singular_name.pluralize}_url"
  reorder_url = send(route_method)

  add_classes!(html_attrs, "rapid-annotated")
  add_data_rapid!(html_attrs, "sortable-collection", :options => options, :events => events)
%>
  <collection class="sortable" merge-attrs="&html_attrs" merge-params>
    <item: id="#{singular_name}_#{this.id}" param>
      <div class="ordering-handle" param="handle" if="&can_edit?(this.position_column)">&uarr;<br/>&darr;</div>
      <do param="default"><card param/></do>
    </item:>
  </collection>
</def>
