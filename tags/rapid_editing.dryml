<def tag="editor"><%= 
  raise HoboError.new("Not allowed to edit") unless can_edit_this?

  if this_type.respond_to?(:macro)
    if this_type.macro == :belongs_to
      belongs_to_editor(options)
    else
      has_many_editor(options)
    end
  else
    call_polymorphic_tag("editor", attributes) or
        raise HoboError.new("<editor> not implemented for #{this.class.name}\##{this_field} " +
                            "(#{this.inspect}:#{this_type})")
  end
%></def>
  

<def tag="has_many_editor">
  <% #TODO: Implement %>
  <a merge_attrs/>
</def>
  
<def tag="editor" for="string">
  <%= in_place_editor "in_place_textfield_bhv", :span, attributes %>
</def>

<def tag="editor" for="text">
  <%= in_place_editor "in_place_textarea_bhv", :div, attributes %>
</def>
  
<def tag="editor" for="html">
  <%= in_place_editor "in_place_html_textarea_bhv", :div, attributes %>
</def>

<def tag="editor" for="datetime">
  <%= string_editor(attributes) %>
</def>

<def tag="editor" for="date">
  <%= string_editor(attributes) %>
</def>

<def tag="editor" for="integer">
  <%= in_place_editor "in_place_textfield_bhv", :span, attributes %>
</def>

<def tag="editor" for="float">
  <%= in_place_editor "in_place_textfield_bhv", :span, attributes %>
</def>

<def tag="editor" for="password">
  <%= raise HoboError, "passwords cannot be edited in place" %>
</def>

<def tag="editor" for="boolean">
  <%= boolean_checkbox_editor(attributes) %>
</def>

<def tag="belongs_to_editor">
  <%= belongs_to_menu_editor(attributes) %>
</def>

<!-------------------->


<def tag="submit" attrs="label, image">
  <input if="image" type="image" src="&image" merge_attrs class="image_input submit_button"/>
  <else>
    <input type="submit" value="#{label}" merge_attrs class="button_input submit_button"/>
  </else>
</def>


<def tag="autocompleter" attrs="completer_model, completer_attr, id, filter, name, value">
  <% refl = this_type
     if refl.respond_to?(:macro) && refl.macro == :belongs_to
       completer_model ||= refl.klass
       completer_attr ||= refl.klass.id_name_column
     else
       completer_model = completer_model.constantize if completer_model.is_a? String
     end
     id ||= this_field_dom_id + "_completer"
     url = object_url(completer_model, "completions",
                      { :for => completer_attr },
                      attributes.select_hash {|k,v| k.to_s.starts_with? "where_"})
  %>
  <input type="text" name="#{name}" id="#{id}" class="autocomplete_bhv"
         autocomplete_url="#{url}" value="#{value}"
         merge_attrs/>
  <div id="<%= id %>_completions" class="completions_popup" style="display:none"></div>
</def>


<def tag="belongs_to_menu_field" attrs="include_none"><%
  raise HoboError.new("Not allowed to edit") unless can_edit_this?
  #Todo: switch to autocompleter for id_name when too many records, and id_name supported
  select_options = this_type.klass.find(:all).select {|x| can_view?(x)}.map { |x|
            [ display_name(:with => x, :no_wrapper => true), x.id ]
          }
  select_options.insert(0, ["(No #{this_type.name.to_s.titleize})", ""]) if this.nil? || include_none
  %>
  <select name="<%= param_name_for_this(true) %>">
    <%= options_for_select(select_options.sort, this ? this.id : "") %>
  </select>
</def>


<def tag="belongs_to_menu_editor"><%
  raise HoboError.new("Not allowed to edit") unless can_edit_this?
  link_id = "#{this_field_dom_id}_editor" %>
  <span id="&link_id" part="rapid_belongs_to_edit">
    <% select_options = this_type.klass.find(:all).select {|x| can_view?(x)}.map {|x|
            [ display_name(:with => x, :no_wrapper => true), x.id ]
          }
       select_options.insert(0, ["(No #{this_type.name.to_s.titleize})", ""]) if this.nil?
       link_id = "#{this_field_dom_id}_editor"
       f = ajax_updater(object_url(this_parent),
                        "Change #{this_field.to_s.titleize}", [link_id],
                        :method => "put",
                        :params => { this_parent.class.name.underscore => {
                            this_type.primary_key_name => Hobo.raw_js('this.value')
                          } })
    %>
    <select onchange="<%= f %>" id="&link_id">
      <%= options_for_select(select_options.sort, this ? this.id : "") %>
    </select>
    <if_this><object_link>View</object_link></if_this>
  </span>
</def>


<def tag="belongs_to_autocompleting_field">
<% refl = this_type
   completer_model ||= refl.klass
   completer_attr ||= refl.klass.id_name_column
   id ||= this_field_dom_id + "_completer"
   where_options = attributes.select_hash {|k,v| k.to_s.starts_with? "where_"}
   url = object_url(completer_model, :completions, { :for => completer_attr }.update(where_options))
  %>

  <input type="text" id="#{id}" class="autocomplete_bhv" autocomplete_url="#{url}"
         name="#{param_name_for_this}" merge_attrs/>
  <div id="#{id}_completions" class="completions_popup" style="display:none"></div>
</def>


<def tag="belongs_to_autocompleting_editor" attrs="update">
  <if_can_edit><%
  return object_link unless can_edit_this?

  id ||= this_field_dom_id + "_completer"
  f = ajax_updater(object_url(this_parent),
                   "Change #{this_field.to_s.titleize}", update,
                   :method => "put",
                   :params => { this_parent.class.name.underscore => {
                       this_field => Hobo.raw_js("$('#{id}').value")
                    } })
  refl = this_type
  completer_model ||= refl.klass
  completer_attr ||= refl.klass.id_name_column
  url = object_url(completer_model, "completions",
                   { :for => completer_attr },
                   attributes.select_hash {|k,v| k.to_s.starts_with? "where_"})
  %>
    <form onsubmit="#{f}; $('#{id}').blur(); return false">
      <input type="text" class="autocomplete_bhv autosubmit" id="#{id}" autocomplete_url="#{url}"
             value="#{this && this.id_name}" merge_attrs />
      <div id="#{id}_completions" class="completions_popup" style="display:none"></div>
    </form>
  </if_can_edit>
  <else>
    <object_link/>
  </else>
</def>


<def tag="string_select_editor" attrs="update, values"><%
  raise HoboError.new("Not allowed to edit") unless can_edit_this?

  values = comma_split(values)
  f = ajax_updater(object_url(this_parent),
                   "Change #{this_field.to_s.titleize}", update,
                   :method => "put",
                   :params => { this_parent.class.name.underscore => {
                       this_field => Hobo.raw_js('this.value')
                    } })
  html_options = add_classes(attributes, editor_class)
%>
  <select onchange="#{f}" merge_attrs="&html_options">
    <%= options_for_select(values, this) %>
  </select>  
</def>


<def tag="boolean_checkbox_editor" attrs="update"><%
  raise HoboError.new("Not allowed to edit") unless can_edit_this?
  f = ajax_updater(object_url(this_parent),
                   "Change #{this_field.to_s.titleize}", update,
                   :method => "put",
                   :params => { this_parent.class.name.underscore => {
                       this_field => Hobo.raw_js('this.checked')
                    } })
  attributes = add_classes(attributes, editor_class)
%>
  <input type="checkbox" value="1" onclick="#{f}"
         merge_attrs="& this ? attributes.merge(:checked => 'checked') : attributes" />
</def>


<def tag="sti_type_field">
  <select name="<%= param_name_for(form_this, form_field_path + ['type']) %>">
    <%= options_for_select(this.class.send(:subclasses).omap{[name.titleize, name]}, this.class.name) %>
  </select>
</def>

      
<def tag="sti_type_editor" attrs="update">
  <% base_class = this.class
     base_class = base_class.superclass while base_class.superclass != ActiveRecord::Base
   f = ajax_updater("#{urlb}/#{controller_for base_class}/#{this.id}",
                      "Change #{this_field.to_s.titleize}", update,
                      :method => "put",
                      :params => { base_class.name.underscore => {
                          "type" => Hobo.raw_js('this.value')
                       } })
  %>

  <select onchange="#{f}">
    <if q="&tagbody">
      <tagbody/>
    </if>
    <else>
      <%= options_for_select(base_class.send(:subclasses).omap{[name.titleize, name]}, this.class.name) %>
    </else>
  </select>
</def>

      
<def tag="integer_select_editor" attrs="min, max, update, nil_option, message">
 <select class="number_editor_bhv" hobo_update="#{update}"
          hobo_model_id="#{this_field_dom_id}"
          merge_attrs="&message ? attributes.merge(:hobo_message => message) : attributes">
   <if q="&this.nil?"><option value=""><%= nil_option || "Choose a value" %></option></if>
   <%= options_for_select((min.to_i..max.to_i).to_a, this) %>
 </select>
</def>


<def tag="select_field">
  <select name="#{param_name_for_this}">
    <tagbody/>
  </select>
</def>
