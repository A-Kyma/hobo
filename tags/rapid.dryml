<include module="Hobo::RapidHelper"/>

<include src="rapid_support"/>
<include src="rapid_document_tags"/>
<include src="rapid_pages"/>
<include src="rapid_editing"/>
<include src="rapid_forms"/>
<include src="rapid_navigation"/>

<def tag="FieldList" attrs="tag">
  <% tag ||= (this.respond_to?(:new_record?) && this.new_record?) ? "input" : "editor" %>
  <field_list merge_attrs="&attributes - attrs_for(:with_fields)">
    <with_fields merge_attrs="&attributes & attrs_for(:with_fields)">
      <field_list_item>
        <item_label param="#{this_field.to_s.sub('?', '')}_label"><%= this_field.to_s.titleize %></item_label>
        <item_value param="#{this_field.to_s.sub('?', '')}_view"><call_tag tag="&tag" /></item_value>
      </field_list_item>
    </with_fields>
  </field_list>
</def>


<def tag="item"><% scope.items << tagbody.call %></def>


<def tag="UL">
  <ul merge_attrs unless="&this.empty?">
    <repeat>
      <li param if="&can_view?" class="#{scope.even_odd} #{this_type.name.underscore}"
          hobo_model_id="#{dom_id this}">
        <tagbody><a/></tagbody>
      </li>
    </repeat>
  </ul>
</def>


<def tag="Table" attrs="fields, field_tag">
  <% field_tag ||= "view" %>
  <table merge_attrs="&attributes - attrs_for(:with_fields)" unless="&this.empty?">
    <thead if="&all_parameters[:thead] || fields" param>
      <tr param="field_heading_row">
        <with_field_names merge_attrs="&all_attributes & attrs_for(:with_fields)">
          <th param="#{this.underscore}_heading"><%= this.titleize %></th>
        </with_field_names>
        <th if="&all_parameters[:controls]" class="controls"/>
      </tr>
    </thead>
    <tbody>
      <repeat>
        <tr param if="&can_view?"
            class="#{scope.even_odd} #{this_type.name.underscore}"
            hobo_model_id="#{dom_id(this)}">
          <if test="&fields">
            <with_fields merge_attrs="&all_attributes & attrs_for(:with_fields)">
              <td><call_tag tag="&field_tag"/></td>
            </with_fields>
            <td class="controls" param="controls" if="&all_parameters[:controls]">
              <a param="edit_link">Edit</a>
              <delete_button param/>
            </td>
          </if>
        </tr>
      </repeat>      
    </tbody>
    <tfoot if="&all_parameters[:tfoot]" param/>
  </table>
</def>


<def tag="image" attrs="src">
  <img src="#{base_url}/images/#{src}" merge_attrs/>
</def>


<def tag="spinner">
  <img src="#{base_url}/hobothemes/#{Hobo.current_theme}/images/spinner.gif" class="hidden" merge_attrs/>
</def>


<def tag="theme_image" attrs="src">
  <img src="#{theme_asset('images/' + src)}" merge_attrs/>
</def>


<def tag="card">
  <%= poly = call_polymorphic_tag('card', attributes) %>
  <div class="card" unless="&poly"><type_name/>: <a/></div>
</def>
  

<def tag="hobo_rapid_javascripts" attrs="tiny_mce"><%=
    res = javascript_include_tag("hobo_rapid")
    res += '<script type="text/javascript">'
    unless Hobo.all_controllers.empty?
      res += "var controllerNames = {" +
        Hobo.all_controllers.map {|c| "#{c.singularize}: '#{c}'"}.join(', ') +
        "}; "
    end
    res += "urlBase = '#{base_url}'; hoboPartPage = '#{view_name}'</script>"
    
    if tiny_mce
      res += javascript_include_tag("tiny_mce/tiny_mce_src") + %{
               <script type="text/javascript">
                 tinyMCE.init({ mode: "textareas", editor_selector: "tiny_mce",
                       plugins: 'save',
                       theme_advanced_buttons1 : "bold, italic, separator, " +
                                                 "bullist, outdent, indent, separator, " +
                                                 "undo, redo, separator, link, unlink",
                       theme_advanced_buttons2 : "",
                       theme_advanced_buttons3 : ""
                 });
               </script>}
    end
    res
%></def>


<def tag="name"><%= 
  if this.nil?
    "(not available)"
  else
    name_tag = find_polymorphic_tag("name")
    if name_tag != "name"
      send(name_tag)
    elsif this.is_a?(Array) && this.respond_to?(:proxy_reflection)
      count
    elsif this.is_a? Class and this < ActiveRecord::Base
      this.name.pluralize.titleize
    elsif this.respond_to?(:name)
      view(merge_attrs(attributes, {:field => 'name'}))
    elsif this.respond_to?(:title)
      view(merge_attrs(attributes, {:field => 'title'}))
    else
      this.to_s
    end
  end
%></def>

<def tag="type_name" attrs="type, plural, lowercase"><%=
  type ||= if this.is_a?(Class)
             this
           elsif this.respond_to? :proxy_reflection
             this.proxy_reflection.klass
           else
             this.class
           end
  name = type.name.titleize
  name = name.pluralize if plural
  name = name.downcase if lowercase
  name
%></def>

<def tag="a" attrs="action, to, params, resource_type, href"><%=
  content = tagbody.call if tagbody
  
  if href || attributes[:name]
    # Regular link - skip all this stuff
  else
    target = to || this
  
    return "(Not Available)" if target.nil? 

    if action == "new"
      # Link to a new object form
      
      new_class_name = if target.respond_to?(:proxy_reflection)
                         target.proxy_reflection.klass.name
                       else
                         target.name
                       end

      href = object_url(target, "new")
      add_classes!(attributes, "new_#{new_class_name.underscore}_link")
      content ||= "New #{new_class_name.titleize}"
    else
      # Link to an existing object
      
      href = if resource_type
               send("formatted_#{model.to_s.downcase}_url", this, resource_type.downcase)
             else
               object_url(target, action, params)
             end
      add_classes!(attributes, "#{target.class.name.underscore}_link")
      
      # Set default link text if none given
      content ||= name
    end
  end
  content_tag :a, content, attributes.update(:href => href)
%></def>

        
<def tag="view" attrs="inline, block, if_blank, no_wrapper"><%=
  raise HoboError, "view of non-viewable field '#{this_field}' of #{this_parent.typed_id rescue this_parent}" unless
    can_view?
   
  if this == nil
    this_type.is_a?(Class) && this_type <= String ? "" : "(Not Available)"
  elsif this_type.respond_to?(:macro)
    if this_type.macro == :belongs_to
      belongs_to_view(attributes)
    elsif this_type.macro == :has_many
      has_many_view(attributes)
    end
  else
    attrs = add_classes(attributes, "view", type_id, type_and_field)
    attrs[:hobo_model_id] = this_field_dom_id if this_parent && this_parent.respond_to?(:typed_id)

    view_tag = find_polymorphic_tag("view")
    
    if view_tag == "view" # i.e. it didn't find a type specific tag
      raise HoboError, "Cannot view: #{this.inspect} (field is #{this_field}, type is #{this.class})"
    else
      view_attrs = attrs_for(view_tag)
      the_view = send(view_tag, attrs & view_attrs)
      
      the_view = if_blank if if_blank && the_view.blank?
      
      if no_wrapper
        the_view
      else
        wrapper = if inline
                    :span
                  elsif block || (this.class.const_defined?(:COLUMN_TYPE) && this.class::COLUMN_TYPE == :text)
                    :div
                  else
                    :span
                  end
        content_tag(wrapper, the_view, attrs - view_attrs)
      end
    end
  end
%></def>

    
<def tag="belongs_to_view"><a/></def>

<def tag="has_many_view"><%= this.empty? ? "(none)" : map_this { a }.join(", ") %></def>

<def tag="view" for="Date"><%= this.to_s(:long) %></def>

<def tag="view" for="Time" attrs="format"><%= format ? this.strftime(format) : this.to_s(:long) %></def>

<def tag="view" for="Numeric" attrs="format"><%= format ? format % this : this.to_s %></def>

<def tag="view" for="Hobo::Text"><%= h(this).gsub("\n", "<br/>") %></def>

<def tag="view" for="html"><%= this %></def>

<def tag="view" for="Hobo::MarkdownString"><%= this.to_html %></def>

<def tag="view" for="Hobo::TextileString"><%= this.to_html %></def>

<def tag="view" for="Hobo::PasswordString">[password withheld]</def>

<def tag="view" for="String"><%= h(this).gsub("\n", "<br/>") %></def>

<def tag="view" for="TrueClass"><%= this ? 'Yes' : 'No' %></def>

<def tag="count" attrs="label, prefix, unless_none"><%=
  raise Exception.new("asked for count of a string") if this.is_a?(String)
   
  if this.is_a?(Class) and this < ActiveRecord::Base
    c = this.count
    label ||= this.name.titleize
  else
    label ||= this.respond_to?(:proxy_reflection) && this.proxy_reflection.name.to_s.singularize.titleize
    c = if this.is_a?(Fixnum)
          this
        elsif this.respond_to?(:count)
          this.count
        else
          this.length
        end
  end
   
  Dryml.last_if = c > 0 if unless_none
  if unless_none && c == 0
    ""
  else
    main = label.blank? ? c : pluralize(c, label)
   
    if prefix.in? %w(are is)
      p = c == 1 ? "is" : "are"
      p + ' ' + main
    else
      main
    end
  end
%></def>


<def tag="theme_stylesheet">
  <link href="<%= base_url %>/hobothemes/<%= Hobo.current_theme %>/stylesheets/application.css"
        media="screen" rel="Stylesheet" type="text/css" />
</def>


<def tag="clearer"><div class='clearer'>&nbsp;</div></def>


<!-- The Tags defined below here are a bit rough and will be improved
in the future - use at your own risk. -->

<def tag="has_many_table" attrs="part_id, delete_buttons, headings, id">
  <table_for headings="&headings" merge_attrs="&true">

    <tagbody/>

    <if test="&delete_buttons != false and can_delete?(this)">
      <td><DeleteButton/></td>
    </if>
  </table_for>
  <else>
    <p>There are no <%= this_type.klass.name.titleize.pluralize.downcase %></p>
  </else>
  <div>
    <CreateButton update="&id || part_id"/>
  </div>
</def>


<def tag="add_by_name" attrs="action_name, add_text, update, part_id">
  <% add_to = this
     refl = this_type
     joins = this_parent.send(refl.through_reflection.name)
     add_name = refl.klass.name.titleize
     action_name ||= "Add #{add_name}"
     add_text ||= "To #{action_name.downcase} #{a_or_an add_name.downcase}, " +
                  "enter its name"
     source = refl.source_reflection.name
  %>
  <tagbody with="&joins"/>
  <with with="&joins.new_without_appending">
    <if test="can_create?">
       <form update="&[update, part_id]" message="&action_name" hidden_fields="*">
         <p>
           <%= add_text %>:
           <belongs_to_autocompleting_field field="&source" where_not_in="&dom_id(add_to)" class="autosubmit"/>
         </p>
       </form>
    </if>
  </with>
</def>


